/**
 * SDF to PDBQT Converter
 * Converts SDF/MOL format to PDBQT format for docking
 * Generates proper ROOT/ENDROOT/TORSDOF records required by AutoDock Vina
 */

// Map element symbols to AutoDock atom types
function getAutoDockAtomType(element: string): string {
    const typeMap: { [key: string]: string } = {
        'C': 'C',
        'N': 'N',
        'O': 'OA',  // Oxygen acceptor
        'H': 'HD',  // Hydrogen donor (simplified - should check bonding)
        'S': 'SA',  // Sulfur acceptor
        'P': 'P',
        'F': 'F',
        'Cl': 'Cl',
        'Br': 'Br',
        'I': 'I',
    };
    return typeMap[element] || element;
}

export function sdfToPdbqt(sdfContent: string): string | null {
    const lines = sdfContent.split('\n');

    if (lines.length < 5) {
        console.warn('[sdfConverter] SDF too short');
        return null;
    }

    // Parse SDF header - atom count is in line 4 (0-indexed line 3)
    const countsLine = lines[3];
    if (!countsLine || countsLine.length < 6) {
        console.warn('[sdfConverter] Invalid counts line');
        return null;
    }

    const atoms: { x: number; y: number; z: number; symbol: string; charge: number }[] = [];
    const atomCount = parseInt(countsLine.substring(0, 3).trim(), 10);
    const bondCount = parseInt(countsLine.substring(3, 6).trim(), 10);

    if (isNaN(atomCount) || atomCount <= 0) {
        console.warn('[sdfConverter] Invalid atom count:', atomCount);
        return null;
    }

    // Parse atoms (start at line 5 / index 4)
    for (let i = 0; i < atomCount && (i + 4) < lines.length; i++) {
        const atomLine = lines[i + 4];
        if (atomLine.length < 34) continue;

        const x = parseFloat(atomLine.substring(0, 10).trim());
        const y = parseFloat(atomLine.substring(10, 20).trim());
        const z = parseFloat(atomLine.substring(20, 30).trim());
        const symbol = atomLine.substring(31, 34).trim();

        if (isNaN(x) || isNaN(y) || isNaN(z)) continue;
        atoms.push({ x, y, z, symbol, charge: 0.0 });
    }

    if (atoms.length === 0) {
        console.warn('[sdfConverter] No atoms parsed from SDF');
        return null;
    }

    // Parse bonds to estimate rotatable bonds (simplified)
    let rotatableBonds = 0;
    const bondStartLine = 4 + atomCount;
    for (let i = 0; i < bondCount && (bondStartLine + i) < lines.length; i++) {
        const bondLine = lines[bondStartLine + i];
        if (bondLine.length < 9) continue;
        const bondType = parseInt(bondLine.substring(6, 9).trim(), 10);
        // Single bonds (type 1) are potentially rotatable
        if (bondType === 1) rotatableBonds++;
    }
    // Cap at reasonable number (subtract ring bonds estimate)
    const torsdof = Math.max(0, Math.min(rotatableBonds - 3, 32));

    console.info(`[sdfConverter] Converted ${atoms.length} atoms from SDF to PDBQT, TORSDOF: ${torsdof}`);

    // Generate PDBQT lines with proper Vina format
    const pdbqtLines: string[] = [];

    // Add header
    pdbqtLines.push('REMARK  Generated by SimDock Pro SDF Converter');
    pdbqtLines.push('REMARK  ' + atoms.length + ' atoms, TORSDOF: ' + torsdof);

    // ROOT section - treat entire molecule as rigid root for simplicity
    // (proper BRANCH detection requires complex chemistry analysis)
    pdbqtLines.push('ROOT');

    for (let i = 0; i < atoms.length; i++) {
        const atom = atoms[i];
        const atomNum = i + 1;
        const atomName = atom.symbol.padEnd(4);
        const adType = getAutoDockAtomType(atom.symbol);

        // PDBQT format: columns are strictly defined
        // HETATM serial name resName chain resSeq x y z occ temp charge type
        const pdbqtLine =
            'HETATM' +
            atomNum.toString().padStart(5) + ' ' +
            atomName + ' ' +
            'LIG' + '     ' +
            '1' + '    ' +
            atom.x.toFixed(3).padStart(8) +
            atom.y.toFixed(3).padStart(8) +
            atom.z.toFixed(3).padStart(8) +
            '  1.00' +
            '  0.00' +
            '    ' +
            atom.charge.toFixed(3).padStart(6) + ' ' +
            adType.padStart(2);
        pdbqtLines.push(pdbqtLine);
    }

    pdbqtLines.push('ENDROOT');
    pdbqtLines.push('TORSDOF ' + torsdof);

    return pdbqtLines.join('\n');
}

/**
 * Check if content is SDF format
 */
export function isSdfFormat(content: string): boolean {
    const contentLower = content.toLowerCase();
    return contentLower.includes('v2000') ||
        contentLower.includes('v3000') ||
        contentLower.includes('m  end') ||
        content.includes('$$$$');
}

/**
 * Convert any molecule format to PDBQT-compatible format
 */
export function convertToViewableFormat(content: string, format: string): string {
    if (format === 'pdbqt' || format === 'pdb') {
        return content; // Already viewable
    }

    if (format === 'sdf' || format === 'mol' || format === 'sd' || isSdfFormat(content)) {
        return sdfToPdbqt(content) || content; // Fallback to content if failed
    }

    // For other formats, return as-is and let viewer handle
    return content;
}
